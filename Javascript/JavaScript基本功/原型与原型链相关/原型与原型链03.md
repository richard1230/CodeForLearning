
## 原型链

1、沿着__proto__寻找继承关系的链条 <br>
2、原型本身也有原型，所有对象都有原型<br>
3、原型链的终点在Object.prototype<br>
4、Object.prototype 里面保存了一个toString方法<br>

看一个例子:
```javascript
// 重写toString方法
Object.prototype.toString=function(){
    //this是什么要看执行的时候谁调用了这个函数。
    console.log("I'm " + this.name + " And I'm " + this.age);
}

// 构造函数
function Foo(name,age){
    this.name = name;
    this.age = age;
}

var fn = new Foo('小明',19);
fn.toString(); // I'm 小明 And I'm 19
console.log(fn.toString === Foo.prototype.__proto__.toString); // true

console.log(fn.__proto__ === Foo.prototype); // true
console.log(Foo.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true
```
![原型链](https://mmbiz.qpic.cn/mmbiz_png/YmmVSe19Qj73L7iaP1nGODEIictnhApDetRjib6s7cuNmB9JtHpcQSLsA46phVos5S6tEgWM860qZGRgw3llleYDw/0?wx_fmt=png)

```
1、fn的构造函数是Foo()，所以：
    fn.__proto__=== Foo.prototype 为true

2、Foo.prototype是一个普通的对象，它的构造函数是Object，所以：
    Foo.prototype.__proto__=== Object.prototype 为true

3、 Object.prototype 也是一个对象，但因为是原型链的终点，里面存储null,所以：
Object.prototype.__proto__ === null 为true

4、原型链：当fn调用toString()时，JS发现fn中没有这个方法，
于是它就去Foo.prototype 中去找，发现还是没有这个方法，
然后就去 Object.prototype中去找，找到了，就调用 Object.prototyp e中的t oString() 方法。

```


## 原型扩展
```javascript
// 1、构造函数字面量
var a = {}// 其实是 var a = new Object() 的语法糖
var a = [] //其实是 var a = new Array() 的语法糖
function Foo(){   } //其实是 var Foo = new Function(...)
```

```javascript
// 2、对象字面量的 constructor 指向系统自带的构造函数，
var obj1 = {}
console.log(obj1); // {__proto__: {constructor: ƒ Object()}}
obj1.__proto__ === Object.prototype//true

// 用户自定义实例化对象的 constructor 指向自定义的构造函数
function Obj() {}
var obj2 = new Obj();
console.log(obj2); // {__proto__: {constructor: ƒ Obj()}}
```





