## 全局匹配

```javascript
let testStr = "Repeat, Repeat, Repeat";
let ourRegex = /Repeat/;
testStr.match(ourRegex);
// 在这里 match 将返回 ["Repeat"]。

// 若要多次搜寻或提取模式匹配，可以使用 g 标志。

let repeatRegex = /Repeat/g;
testStr.match(repeatRegex);
// 这里 match 返回值 ["Repeat", "Repeat", "Repeat"]
```

使用正则表达式 starRegex，从字符串 twinkleStar 中匹配所有的 Twinkle 单词并提取出来。

```javascript
let twinkleStar = "Twinkle, twinkle, little star";
let starRegex = /Twinkle/gi; // 修改这一行
let result1 = twinkleStar.match(starRegex); // 修改这一行
console.log(result1);//["Twinkle", "twinkle"]

```

## 匹配字符串的开头(^)

在之前的挑战中，使用字符集中前插入符号（^）来创建一个否定字符集，
(在[]里面的^为否定,其他情况为以...开始)
形如` [^thingsThatWillNotBeMatched]`。 除了在字符集中使用之外，脱字符还用于匹配字符串的开始位置。

```javascript

let firstString = "Ricky is first and can be found.";
let firstRegex = /^Ricky/;
firstRegex.test(firstString);
let notFirst = "You can't find Ricky now.";
firstRegex.test(notFirst);
//第一次 test 调用将返回 true，而第二次调用将返回 false。

let rickyAndCal = "Cal and Ricky both like racing.";
let calRegex = /^Cal/; // 是否以 Cal为开头
let calRegex1 = /^Cu/; // 是否以 Cu为开头

let result0 = calRegex.test(rickyAndCal);
let result111 = calRegex1.test(rickyAndCal);


console.log("^匹配字符串的开头==============");
console.log(result0); //true
console.log(result111);//false
```

## 匹配字符串的末尾

```javascript
// 可以使用正则表达式的美元符号 $ 来搜寻字符串的结尾。

let theEnding = "This is a never ending story";
let storyRegex = /story$/;
storyRegex.test(theEnding);
let noEnding = "Sometimes a story will have to end";
storyRegex.test(noEnding);
// 第一次 test 调用将返回 true, 而第二次调用将返回 false。

let caboose = "The last car on a train is the caboose";
let lastRegex = /caboose$/; // 修改这一行
let lastRegex1 = /coose$/; // 修改这一行

let result01 = lastRegex.test(caboose);
let result0011 = lastRegex1.test(caboose);


console.log(result01);//true
console.log(result0011);//false
```



