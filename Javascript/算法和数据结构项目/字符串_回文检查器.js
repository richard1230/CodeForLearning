/*
在这道题目中，我们需要把空格、特殊符号都去掉。.replace() 方法接收的第一个参数为一个正则表达式(或字符)，第二个参数为字符(或一个 function)。
作用就是把通过第一个参数匹配到的字符给替换成第二个参数的字符。括号中的参数类型，这道题中并不会用到

那么，我们需要做的就是，在第一个参数中匹配空格和特殊符号，第二个参数中传入 "" 空字符，顺便，记得要在正则结尾写上 /g，否则不能替换全部

匹配空格和特殊符号，空格是 \s (请注意，反之不成立，\s 不光是空格，还包括制表符 tab，以及换行符 \r 或者 \r\n)。然而，特殊符号，并没有一个通用的匹配写法

有些朋友可能会想这样做，事实上我也真的见过有不少人这样做：/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/g，嗯，没毛病

但我们换一种思路想想，其实我们要做的，就是”保留英文字母和数字”。这样，正则就变得简单很多了，只需要 /[^A-Za-z0-9]/g。另一方面，如果你先 .toLowerCase() 再 .replace()，正则就可以直接写成 /[^a-z0-9]/g

如果你决定用 \w 的相反形式 \W，没有问题，但一定要记住，\w 不仅包含英文字母，还包含了下划线 _。因此，你需要写成 /[\W_]/g，或者写成 /\W|_/g

思路:
在判断之前，以下这两步是一定要做的，顺序无所谓：
去掉所有”干扰项”，比如特殊字符和空格
把字符串转换成小写
逻辑判断部分，大体可以分为两种思路：
翻转字符串，并与排除干扰项之后的字符串比较，如果相等就返回 true，反之则为 false
双指针。用两个变量代表两个”指针”，一个从开头往右移动，另一个从结尾向左移动，比较每次指向的字符是否相等
对于第一种”翻转字符串后比较”的思路，可以参考之前做过的 Reverse a String 那道题，有以下两种实现方式：
先把字符串变成数组，用数组的 .reverse() 方法，然后合并成字符串
不用数组，直接通过 for 循环翻转字符串，然后与排除干扰项后的字符串比较
对于第二种”双指针”的思路，也有两种实现方式：
循环，设置一个指针初始值为开头(0) 另一个为结尾(str.length - 1)，然后判断当前字符是否相等。相等就把左边的指针向右移动一位(++)，同时右边的指针向左移动一位(–)。如果不相等就可以直接跳出了，并返回 false
递归，不需要创建指针。每次都判断字符串的开头和结尾是否相等，递归调用的时候参数传入去掉头尾的 str
建议先用第一种思路写，通过了再试试第二种思路
如果要写递归，一定要记得设置好边界条件和跳出条件
*/

function palindrome(str) {

  var lowerStr = str.toLowerCase();
  // 替换掉干扰项,注意:这里的^ 指的是非的意思，不是以。。。开头
  var replacedStr = lowerStr.replace(/[^a-z0-9]/g, "");
  // 分割成数组
  var strArr = replacedStr.split("");
  // 翻转数组
  var reversedArr = strArr.reverse();
  // 合并成字符
  var reversedStr = reversedArr.join("");
  // 返回判断结果
  return replacedStr === reversedStr;


}

console.log(palindrome("0_0 (: /-\ :) 0-0"));
console.log(palindrome("race car"));
console.log(palindrome("A man, a plan, a canal. Panama"));


const p = 'The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?';

console.log(p.replace('dog', 'monkey'));
// expected output: "The quick brown fox jumps ove
console.log(p);


/*
例如，/^A/ 并不会匹配 "an A" 中的 'A'，但是会匹配 "An E" 中的 'A'。

当 '^' 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。反向字符集合 一节有详细介绍和示例。


一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。

例如，[^abc] 和 [^a-c] 是一样的。他们匹配"brisket"中的‘r’，也匹配“chop”中的‘h’

* */
